"use strict";(self.webpackChunkchatgpt_api=self.webpackChunkchatgpt_api||[]).push([[619],{9619:(C,m,a)=>{a.r(m),a.d(m,{ZeroShotAgent:()=>c});var l=a(15861),f=a(40443),v=a(194);const b="Answer the following questions as best you can. You have access to the following tools:",T="Begin!\n\nQuestion: {input}\nThought:{agent_scratchpad}",y=function(){var u=(0,l.Z)(function*(t,e,n,o,r){if(n.load_from_llm_and_tools){if(!t)throw new Error("Loading from llm and tools, llm must be provided.");if(!e)throw new Error("Loading from llm and tools, tools must be provided.");return o(t,e,n)}if(!n.llm_chain)throw new Error("Loading from constructor, llm_chain must be provided.");const i=yield f.LLMChain.deserialize(n.llm_chain);return r({...n,llmChain:i})});return function(e,n,o,r,i){return u.apply(this,arguments)}}();class g extends Error{constructor(t,e){super(t),Object.defineProperty(this,"output",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),this.output=e}}class P{get returnValues(){return["output"]}get allowedTools(){}_agentType(){throw new Error("Not implemented")}returnStoppedResponse(t,e,n){if("force"===t)return Promise.resolve({returnValues:{output:"Agent stopped due to max iterations."},log:""});throw new Error(`Invalid stopping method: ${t}`)}prepareForOutput(t,e){return(0,l.Z)(function*(){return{}})()}}class x extends P{_agentActionType(){return"single"}}class _ extends x{get allowedTools(){return this._allowedTools}get inputKeys(){return this.llmChain.inputKeys.filter(t=>"agent_scratchpad"!==t)}constructor(t){super(),Object.defineProperty(this,"llmChain",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),Object.defineProperty(this,"_allowedTools",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),this.llmChain=t.llmChain,this._allowedTools=t.allowedTools}extractToolAndInput(t){return(0,l.Z)(function*(){throw new Error("Not implemented")})()}static createPrompt(t,e){throw new Error("Not implemented")}static fromLLMAndTools(t,e,n){throw new Error("Not implemented")}static validateTools(t){}_stop(){return[`\n${this.observationPrefix()}`]}finishToolName(){return"Final Answer"}constructScratchPad(t){return t.reduce((e,{action:n,observation:o})=>e+[n.log,`${this.observationPrefix()}${o}`,this.llmPrefix()].join("\n"),"")}_plan(t,e,n){var o=this;return(0,l.Z)(function*(){const r=o.constructScratchPad(t),i={...e,agent_scratchpad:n?`${r}${n}`:r};0!==o._stop().length&&(i.stop=o._stop());const s=yield o.llmChain.predict(i),h=yield o.extractToolAndInput(s);if(!h)throw new g(`Invalid output: ${s}`,s);const p={tool:h.tool,toolInput:h.input,log:s};return p.tool===o.finishToolName()?{returnValues:{output:p.toolInput},log:p.log}:p})()}plan(t,e){return this._plan(t,e)}returnStoppedResponse(t,e,n){var o=this;return(0,l.Z)(function*(){if("force"===t)return{returnValues:{output:"Agent stopped due to max iterations."},log:""};if("generate"===t)try{const r=yield o._plan(e,n,"\n\nI now need to return a final answer based on the previous steps:");return"returnValues"in r?r:{returnValues:{output:r.log},log:r.log}}catch(r){if(!(r instanceof g))throw r;return{returnValues:{output:r.output},log:r.output}}throw new Error(`Invalid stopping method: ${t}`)})()}static deserialize(t){return(0,l.Z)(function*(){if("zero-shot-react-description"===t._type){const{ZeroShotAgent:e}=yield Promise.resolve().then(a.bind(a,9619));return e.deserialize(t)}throw new Error("Unknown agent type")})()}}const w="Final Answer:";class c extends _{constructor(t){super(t)}_agentType(){return"zero-shot-react-description"}observationPrefix(){return"Observation: "}llmPrefix(){return"Thought:"}static validateTools(t){const e=t.find(n=>!n.description);if(e)throw new Error(`Got a tool ${e.name} without a description. This agent requires descriptions for all tools.`)}static createPrompt(t,e){const{prefix:n=b,suffix:o=T,inputVariables:r=["input","agent_scratchpad"]}=e??{},p=[n,t.map(d=>`${d.name}: ${d.description}`).join("\n"),`Use the following format:\n\nQuestion: the input question you must answer\nThought: you should always think about what to do\nAction: the action to take, should be one of [${t.map(d=>d.name).join("\n")}]\nAction Input: the input to the action\nObservation: the result of the action\n... (this Thought/Action/Action Input/Observation can repeat N times)\nThought: I now know the final answer\nFinal Answer: the final answer to the original input question`,o].join("\n\n");return new v.PromptTemplate({template:p,inputVariables:r})}static fromLLMAndTools(t,e,n){c.validateTools(e);const o=c.createPrompt(e,n),r=new f.LLMChain({prompt:o,llm:t});return new c({llmChain:r,allowedTools:e.map(i=>i.name)})}extractToolAndInput(t){return(0,l.Z)(function*(){if(t.includes(w)){const n=t.split(w);return{tool:"Final Answer",input:n[n.length-1].trim()}}const e=/Action: (.*)\nAction Input: (.*)/s.exec(t);if(!e)throw new Error(`Could not parse LLM output: ${t}`);return{tool:e[1].trim(),input:e[2].trim().replace(/^"+|"+$/g,"")}})()}static deserialize(t){return(0,l.Z)(function*(){const{llm:e,tools:n,...o}=t;return y(e,n,o,(r,i,s)=>c.fromLLMAndTools(r,i,{prefix:s.prefix,suffix:s.suffix,inputVariables:s.input_variables}),r=>new c(r))})()}}}}]);